#!/usr/bin/env python3

import os
import sys
import glob
import string
import argparse
import subprocess
import configparser
import re
from collections import defaultdict
from pathlib import Path


def get_valid_boards(path):
    bt = defaultdict(list)

    name_expression = re.compile(r"^([\w\d_\-]+)\.name.*$")
    sub_expression = re.compile(r"^([\w\d_\-]+)\.menu\.(?:cpu|chip)\.([\w\d_\-]+)=.*$")

    for line in path.open():
        name_match = name_expression.match(line)
        sub_match = sub_expression.match(line)

        if name_match is not None:
            board = name_match.group(1)

            if not board in bt:
                bt[board] = []

        if sub_match is not None:
            board, sub = (sub_match.group(1), sub_match.group(2))
            bt[board].append(sub)

    return bt


def git_hash():
    """Return first four characters of the hash"""
    hash = subprocess.getoutput("git rev-parse --short HEAD")
    return hash[:4]


class Config:
    def __init__(self, path: Path):
        config = configparser.ConfigParser()
        config.read(path)

        def get_path(section, option, default):
            path = Path(config[section].get(option, default))

            if not path.exists():
                raise RuntimeError(f"{path} does not exist")

            return path

        try:
            self.arduino_dir = get_path("general", "arduino_dir", "/usr/share/arduino")
            self.ardmk_dir = get_path("general", "ardmk_dir", "./libs/Arduino-Makefile").absolute()
            self.avrdude_conf = get_path("general", "avrdude_conf", "/etc/avrdude.conf")
            self.user_lib_path = get_path("general", "user_lib_path", "./libs").absolute()
            self.board = config["general"].get("board")
            self.sub = config["general"].get("sub", None)
            self.extra_cxx_flags = config["general"].get("extra_cxx_flags", "")

            self.with_mock_controller = config["general"].getboolean("with_mock_controller", False)

            self.with_ds18b20 = config.has_section("ds18b20")
            self.ds18b20_pin = config["ds18b20"].getint("pin") if self.with_ds18b20 else None

            self.with_sh1106 = config.has_section("sh1106")
            self.sh1106_rst = config["sh1106"].getint("rst") if self.with_sh1106 else None
            self.sh1106_dc = config["sh1106"].getint("dc") if self.with_sh1106 else None
            self.sh1106_cs = config["sh1106"].getint("cs") if self.with_sh1106 else None
            self.sh1106_din = config["sh1106"].getint("din") if self.with_sh1106 else None
            self.sh1106_clk = config["sh1106"].getint("clk") if self.with_sh1106 else None

            self.with_ky040 = config.has_section("ky040")
            self.ky040_sw = config["ky040"].get("sw") if self.with_ky040 else None
            self.ky040_dt = config["ky040"].get("dt") if self.with_ky040 else None
            self.ky040_clk = config["ky040"].get("clk") if self.with_ky040 else None
        except KeyError as e:
            raise ValueError(f"Could not find configuration entry: {e}")

        path = config["general"].get("boards_txt", None)
        path = Path(path) if path else self.arduino_dir / "hardware/arduino/avr/boards.txt"

        if not path.exists():
            raise RuntimeError(f"{path} does not exist")

        boards = get_valid_boards(path)

        if self.board not in boards:
            raise ValueError(f"Unknown board '{self.board}', valid boards: {', '.join(boards.keys())}")

        subs = boards[self.board]

        if subs and not self.sub:
            raise ValueError(f"Board '{self.board}' has subtypes, specify one of {', '.join(subs)}")

        if self.sub and self.sub not in subs:
            raise ValueError(f"Unknown board subtype '{self.sub}', valid subtypes for '{self.board}': {', '.join(subs)}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("config", type=Path, help="Configuration file (see config.ini.template)")
    args = parser.parse_args()

    try:
        config = Config(args.config)
    except (ValueError, RuntimeError) as e:
        sys.stderr.write(f"Error: {e}\n")
        sys.exit(1)

    VERSION_STRING = git_hash()
    ARDUINO_LIBS = []
    CONFIG = []

    if config.with_mock_controller:
        CONFIG.append("#define WITH_MOCK_CONTROLLER 1")

    if config.with_ds18b20:
        ARDUINO_LIBS.append("OneWire")
        ARDUINO_LIBS.append("DallasTemperature")
        ARDUINO_LIBS.append("ds18b20")
        CONFIG.append("#define WITH_DS18B20 1")
        CONFIG.append(f"#define DS18B20_PIN {config.ds18b20_pin}")

    if config.with_sh1106:
        ARDUINO_LIBS.append("SPI")
        ARDUINO_LIBS.append("sh1106")
        CONFIG.append("#define WITH_SH1106 1")
        CONFIG.append(f"#define SH1106_RST {config.sh1106_rst}")
        CONFIG.append(f"#define SH1106_DC {config.sh1106_dc}")
        CONFIG.append(f"#define SH1106_CS {config.sh1106_cs}")
        CONFIG.append(f"#define SH1106_DIN {config.sh1106_din}")
        CONFIG.append(f"#define SH1106_CLK {config.sh1106_clk}")

    if config.with_ky040:
        CONFIG.append("#define WITH_KY040 1")
        CONFIG.append(f"#define KY040_SW {config.ky040_sw}")
        CONFIG.append(f"#define KY040_DT {config.ky040_dt}")
        CONFIG.append(f"#define KY040_CLK {config.ky040_clk}")

    with Path("Makefile").open("w") as f:
        template = string.Template(open("Makefile.in").read())

        d = dict(ARDUINO_DIR=config.arduino_dir,
                 ARDUINO_LIBS=" ".join(ARDUINO_LIBS),
                 ARDMK_DIR=config.ardmk_dir,
                 AVRDUDE_CONF=config.avrdude_conf,
                 BOARD_TAG=config.board,
                 BOARD_SUB=config.sub or "",
                 ARDMK_LOCATION=config.ardmk_dir / "Arduino.mk",
                 USER_LIB_PATH=config.user_lib_path,
                 EXTRA_CXX_FLAGS=config.extra_cxx_flags)

        f.write(template.safe_substitute(d))

    with Path("config.h").open("w") as f:
        template = string.Template(open("config.h.in").read())
        d = dict(VERSION_STRING=VERSION_STRING)
        f.write(template.safe_substitute(d))
        f.write("\n".join(CONFIG))
        f.write("\n")
